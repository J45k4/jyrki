use crate::llm::{GenRequest, SuccessfullGenResponse};
use crate::tool::Tool;
use crate::{Message, ToolUse};
use anyhow::bail;
use reqwest::Client;
use reqwest::StatusCode;
use serde::Deserialize;

#[derive(Deserialize, Debug)]
struct ChatCompletion {
    id: String,
    object: String,
    created: i64,
    model: String,
    choices: Vec<Choice>,
    usage: Usage,
    system_fingerprint: String,
    service_tier: Option<String>,
}

impl ChatCompletion {
	fn to_successfull_gen_response(&self) -> anyhow::Result<SuccessfullGenResponse> {
		let first_choice = self.choices.first().ok_or_else(|| anyhow::anyhow!("no choices"))?;

		let mut res = SuccessfullGenResponse {
			content: first_choice.message.content.clone().unwrap_or_else(|| "".to_string()),
			prompt_tokens: self.usage.prompt_tokens,
			completion_tokens: self.usage.completion_tokens,
			total_tokens: self.usage.total_tokens,
			tools: vec![]
		};
	
		if let Some(tool_calls) = &first_choice.message.tool_calls {
			for tool_call in tool_calls {
				if tool_call.type_ == "function" {
					res.tools.push(ToolUse {
						id: tool_call.id.clone(),
						name: tool_call.function.name.clone(),
						args: tool_call.function.arguments.clone(),
					});
				}
			}
		}

		Ok(res)
	}
}

fn create_successfull_gen_response(chat_completion: ChatCompletion) -> SuccessfullGenResponse {
	let first_choice = chat_completion.choices.first().unwrap();

	let mut res = SuccessfullGenResponse {
		content: first_choice.message.content.clone().unwrap_or_else(|| "".to_string()),
		prompt_tokens: chat_completion.usage.prompt_tokens,
		completion_tokens: chat_completion.usage.completion_tokens,
		total_tokens: chat_completion.usage.total_tokens,
		tools: vec![],
	};

	if let Some(tool_calls) = &first_choice.message.tool_calls {
		for tool_call in tool_calls {
			if tool_call.type_ == "function" {
				res.tools.push(ToolUse {
					id: tool_call.id.clone(),
					name: tool_call.function.name.clone(),
					args: tool_call.function.arguments.clone(),
				});
			}
		}
	}

	res
}
#[derive(Deserialize, Debug)]
struct Choice {
    index: u32,
    message: OAIMessage,
    logprobs: Option<Logprobs>,
    finish_reason: String,
}

#[derive(Deserialize, Debug)]
struct OAIMessage {
    role: String,
    content: Option<String>,
	tool_calls: Option<Vec<ToolCall>>,
    refusal: Option<String>,
}

#[derive(Deserialize, Debug)]
struct ToolCall {
    id: String,
    #[serde(rename = "type")]
    type_: String,  // `type` is a reserved keyword in Rust, so we use `type_` instead
    function: Function,
}

#[derive(Deserialize, Debug)]
struct Function {
    name: String,
    arguments: String,  // Arguments in JSON format as generated by the model
}

#[derive(Deserialize, Debug)]
struct FunctionCall {
    name: String,
    arguments: String,
}

#[derive(Deserialize, Debug)]
struct Logprobs {
    content: Option<Vec<LogprobContent>>,
    refusal: Option<Vec<LogprobRefusal>>,
}

#[derive(Deserialize, Debug)]
struct LogprobContent {
    // Define fields for log probability of message content tokens
}

#[derive(Deserialize, Debug)]
struct LogprobRefusal {
    // Define fields for log probability of refusal tokens
}

#[derive(Deserialize, Debug)]
struct Usage {
    prompt_tokens: u32,
    completion_tokens: u32,
    total_tokens: u32,
}


pub async fn gen(req: GenRequest, client: Client) -> anyhow::Result<SuccessfullGenResponse> {
    let body = serde_json::to_string(&req)?;
    let apikey = match std::env::var("OPENAI_API_KEY") {
		Ok(key) => key,
		Err(_) => {
			bail!("OPENAI_API_KEY not set");
		}
	};

	log::info!("body: {}", body);

    let res = client
        .post("https://api.openai.com/v1/chat/completions")
        .header("Authorization", format!("Bearer {}", apikey))
        .header("Content-Type", "application/json")
        .body(body)
        .send()
        .await?;

    let status_code = res.status();
	let text = res.text().await?;

	if status_code != StatusCode::OK {
		log::error!("request failed with code {}", status_code);
		log::error!("response: {}", text);
		bail!("request failed with code {}", status_code);
	}

	log::info!("response: {}", text);
    let chat_completion: ChatCompletion = serde_json::from_str(&text)?;
	let res = chat_completion.to_successfull_gen_response()?;
    Ok(res)
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_parse_toolcall() {
		let str = r#"{
		"id": "asdfghasdfasdg",
		"object": "chat.completion",
		"created": 12412412,
		"model": "gpt-4o-mini-2024-07-18",
		"choices": [
			{
			"index": 0,
			"message": {
				"role": "assistant",
				"content": null,
				"tool_calls": [
					{
						"id": "asdgasdgagds",
						"type": "function",
						"function": {
							"name": "write_file",
							"arguments": "{\"content\":\"print('Hello, World!')\",\"linenumber\":0,\"path\":\"hello_world.py\"}"
						}
					}
				],
				"refusal": null
			},
			"logprobs": null,
			"finish_reason": "tool_calls"
			}
		],
		"usage": {
			"prompt_tokens": 380,
			"completion_tokens": 31,
			"total_tokens": 411
		},
		"system_fingerprint": "bvnmvnbm"
		}"#;

		let res = serde_json::from_str::<ChatCompletion>(str).unwrap();
		println!("{:?}", res);

		let result = res.to_successfull_gen_response().unwrap();

		println!("{:?}", result);
	}
}